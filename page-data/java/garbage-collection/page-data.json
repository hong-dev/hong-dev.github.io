{"componentChunkName":"component---src-templates-blog-post-js","path":"/java/garbage-collection/","result":{"data":{"site":{"siteMetadata":{"title":"hong_devlog","author":"hongdev","siteUrl":"https://hong-dev.github.io","comment":{"disqusShortName":"","utterances":"hong-dev/hong-dev.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"1aa8ab22-673c-5ef9-b7bc-034a16a42dff","excerpt":"Garbage Collection Java 프로그램이 자동으로 메모리 관리를 수행하는 프로세스 Java에서 객체가 만들어지면 Heap이라는 메모리 공간에 저장된다. 객체를 만들면, 자바에서는 그 객체의 크기에 따라 heap 안에 적당한 메모리 공간을 할당한다. 모든 객체는 (언제, 어디에서, 어떻게 만들어졌든 상관없이) garbage collection 기능이 있는 Heap에 산다. JVM에서 어떤 객체가 절대로 다시 쓰이지 않을 것이라는 결론을 내릴 수 있으면 그 객체는 garbage…","html":"<h1 id=\"garbage-collection\" style=\"position:relative;\"><a href=\"#garbage-collection\" aria-label=\"garbage collection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Garbage Collection</h1>\n<ul>\n<li>Java 프로그램이 자동으로 메모리 관리를 수행하는 프로세스</li>\n<li>\n<p>Java에서 객체가 만들어지면 <strong>Heap</strong>이라는 메모리 공간에 저장된다.</p>\n<p>객체를 만들면, 자바에서는 그 객체의 크기에 따라 heap 안에 적당한 메모리 공간을 할당한다.</p>\n</li>\n<li>모든 객체는 (언제, 어디에서, 어떻게 만들어졌든 상관없이) garbage collection 기능이 있는 Heap에 산다.</li>\n<li>\n<p>JVM에서 어떤 객체가 절대로 다시 쓰이지 않을 것이라는 결론을 내릴 수 있으면 그 객체는 garbage collection 대상이 된다.</p>\n<p>더이상 필요하지 않은 객체들은 삭제되고, 그 객체들에 할당되었던 메모리를 되찾아온다.</p>\n</li>\n<li>\n<p>GC는 개발자가 메모리 할당 해제를 수동으로 처리하지 않아도 되게 한다.</p>\n<p>결과적으로 메모리 문제들과 관련된 몇몇 버그들이 GC에 의해 제거되거나 크게 감소한다.</p>\n</li>\n</ul>\n<br>  \n<h1 id=\"types-of-gc\" style=\"position:relative;\"><a href=\"#types-of-gc\" aria-label=\"types of gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Types of GC</h1>\n<h3 id=\"minor-gc\" style=\"position:relative;\"><a href=\"#minor-gc\" aria-label=\"minor gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Minor GC</h3>\n<ul>\n<li>Young generation heap memory에서 접근불가능(unreachable)한 상태가 된 객체들이 제거된다.</li>\n<li>\n<p><strong>Young Generation</strong> 영역: 새롭게 생성한 객체의 대부분이 여기에 저장된다.</p>\n<p>금방 unreachable한 상태가 되기 때문에, 매우 많은 객체가 이 영역에서 생성되었다가 사라진다.</p>\n</li>\n</ul>\n<h3 id=\"major-gc\" style=\"position:relative;\"><a href=\"#major-gc\" aria-label=\"major gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Major GC</h3>\n<ul>\n<li>Old generation이나 Permanent generation에서 접근불가능(unreachable)한 상태가 된 객체들이 제거된다.</li>\n<li>\n<p><strong>Old Generation</strong> 영역: Minor GC (Young generation)에서 살아남은 객체들이 여기로 복사된다.</p>\n<p>대부분 Young 영역보다 크게 할당하며, 크기가 큰 만큼 young generation 보다 GC가 적게 발생한다.</p>\n</li>\n<li>\n<p><strong>Permanent Generation</strong> 영역: 프로그램에서 사용되는 class와 method를 설명하기 위해 JVM이 필요로하는 metadata가 포함된다. (런타임 시에 JVM에 의해 채워진다.)</p>\n<p>Old 영역에서 살아남은 객체가 영원히 남아있는 곳이 <strong>아니다.</strong></p>\n<p>이 영역에서도 GC가 발생할 수 있는데, 이곳의 GC도 Major GC에 포함된다.</p>\n</li>\n</ul>\n<br>\n<h1 id=\"how-gc-works\" style=\"position:relative;\"><a href=\"#how-gc-works\" aria-label=\"how gc works permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How GC works</h1>\n<h3 id=\"stop-the-world\" style=\"position:relative;\"><a href=\"#stop-the-world\" aria-label=\"stop the world permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stop The World</h3>\n<ul>\n<li>메모리를 확보하기 위해, JVM이 잠시 application 실행을 중지하고 GC를 실행한다.</li>\n<li>GC thread를 제외한 모든 thread는, GC가 완료될 때까지 실행이 중지된다.</li>\n<li>최근 GC 구현에서는, 별도의 thread를 사용하는 background에서 가능한 한 많은 작업을 수행하여 stop-the-world의 영향을 최소화하려고 한다. 예를 들어, application process가 실행되는 동안, unreachable한 garbage instances를 marking 해놓는다.</li>\n<li>GC는 해제할 메모리를 결정하기 위해 CPU resource를 사용한다.</li>\n<li>시간이 지남에 따라 다양한 GC가 개발되어, GC 중에 발생하는 application 일시 중지 시간을 줄이고, GC와 관련된 성능 저하를 개선되고 있다.</li>\n</ul>\n<h3 id=\"mark-and-sweep\" style=\"position:relative;\"><a href=\"#mark-and-sweep\" aria-label=\"mark and sweep permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mark and Sweep</h3>\n<ul>\n<li><strong>Mark</strong>: 사용되는 메모리와 사용하지 않는 메모리를 식별한다.</li>\n<li><strong>Sweep</strong>: Mark 단계에서 사용하지 않는 것으로 분류된 객체들을 제거함으로써 메모리를 해제한다.</li>\n</ul>\n<br>\n<br>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em>Reference</em></h3>\n<blockquote>\n<p><a href=\"https://www.eginnovations.com/blog/what-is-garbage-collection-java/\"><em>What is Garbage Collection in Java and Why is it Important?</em></a><br>\n<a href=\"https://mangkyu.tistory.com/118\"><em>Garbage Collection(가비지 컬렉션)의 개념 및 동작 원리</em></a></p>\n</blockquote>","frontmatter":{"title":"Garbage Collection (GC)","date":"January 08, 2022","category":"java","thumbnail":null}}},"pageContext":{"slug":"/java/garbage-collection/","previous":{"fields":{"slug":"/java/static-volatile/"},"frontmatter":{"title":"Static vs Volatile variables","category":"java","draft":false}},"next":{"fields":{"slug":"/android/activity-lifecycle/"},"frontmatter":{"title":"Android Activity Lifecycle","category":"android","draft":false}}}},"staticQueryHashes":["2353110810","3128451518"]}