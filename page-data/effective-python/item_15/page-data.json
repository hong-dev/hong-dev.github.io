{"componentChunkName":"component---src-templates-blog-post-js","path":"/effective-python/item_15/","result":{"data":{"site":{"siteMetadata":{"title":"hong_devlog","author":"hongdev","siteUrl":"https://hong-dev.github.io","comment":{"disqusShortName":"","utterances":"hong-dev/hong-dev.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"0289cd30-a983-5ed1-9644-10170a3b3eb3","excerpt":"Effective Python: Second Edition 내용 정리 Item 15: Be Cautious When Relying on dict Insertion Ordering Python 3.5 까지는 dictionary의 key 값에 순서가 없었다. 그래서 입력한 dict element의 순서와 상관없이 임의로 print 되기 때문에, test case를 짜거나 debugging 할 때 어려움이 있었다. 그 이유는 Python interpreter가 시작할 때 할당된 random seed…","html":"<blockquote>\n<p><em>Effective Python: Second Edition 내용 정리</em></p>\n</blockquote>\n<h2 id=\"item-15-be-cautious-when-relying-on-dict-insertion-ordering\" style=\"position:relative;\"><a href=\"#item-15-be-cautious-when-relying-on-dict-insertion-ordering\" aria-label=\"item 15 be cautious when relying on dict insertion ordering permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Item 15: Be Cautious When Relying on dict Insertion Ordering</h2>\n<ul>\n<li>\n<p>Python 3.5 까지는 dictionary의 key 값에 순서가 없었다.<br>\n그래서 입력한 dict element의 순서와 상관없이 임의로 print 되기 때문에, test case를 짜거나 debugging 할 때 어려움이 있었다.</p>\n<p>그 이유는 Python interpreter가 시작할 때 할당된 random seed가 hash built-in function과 결합되는 방식으로 dictionary가 구현되어 있었기 때문이다. (<code class=\"language-text\">hash table algorithm</code>)</p>\n</li>\n</ul>\n<br>\n<ul>\n<li>\n<p>Python 3.7 부터는 dictionary가 입력된 순서를 보존해서, 프로그래머가 처음 생성했던 dictionary와 항상 똑같이 print 할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># Python 3.5</span>\nalp <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">:</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'d'</span><span class=\"token punctuation\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">}</span>\n\nalp\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'d'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">4</span><span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># Python 3.7</span>\nalp <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">:</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'d'</span><span class=\"token punctuation\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">}</span>\n\nalp\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">:</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'d'</span><span class=\"token punctuation\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<br>\n<ul>\n<li>\n<p><code class=\"language-text\">keys</code>, <code class=\"language-text\">values</code>, <code class=\"language-text\">items</code>, <code class=\"language-text\">popitem</code>과 같이 iteration order에 의존하는 dict의 method들은, python 3.5에서는 그 순서가 랜덤이었다면, 이제는 일관된 순서로 보여준다.</p>\n<p><code class=\"language-text\">dict.popitem()</code>의 경우에는 항상 가장 마지막에 입력된 item을 pop 한다.</p>\n</li>\n</ul>\n<br>\n<ul>\n<li>\n<p><code class=\"language-text\">Keyword arguments</code> 인 <code class=\"language-text\">**kwargs</code> catch-all parameter의 경우에도, 함수 호출하는 parameter를 넣었을 때 그 parameter가 입력한 순서대로 나오지 않는 것처럼 보여서 function call에 대해 debug 하기가 어려웠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># Python 3.5</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">alp</span><span class=\"token punctuation\">(</span><span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> key<span class=\"token punctuation\">,</span> value <span class=\"token keyword\">in</span> kwargs<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'%s = %s'</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># f-strings는 python 3.6에서 추가된 기능</span>\n\nalp<span class=\"token punctuation\">(</span>a<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> c<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span>\na <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\nc <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\nb <span class=\"token operator\">=</span> <span class=\"token number\">2</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># Python 3.7</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">alp</span><span class=\"token punctuation\">(</span><span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> key<span class=\"token punctuation\">,</span> value <span class=\"token keyword\">in</span> kwargs<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f'</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>key<span class=\"token punctuation\">}</span></span><span class=\"token string\"> = </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>value<span class=\"token punctuation\">}</span></span><span class=\"token string\">'</span></span><span class=\"token punctuation\">)</span>\n\nalp<span class=\"token punctuation\">(</span>a<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> c<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span>\na <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\nb <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\nc <span class=\"token operator\">=</span> <span class=\"token number\">3</span></code></pre></div>\n</li>\n</ul>\n<br>\n<ul>\n<li>\n<p>class도 instance의 dictionaries를 dict type으로 사용한다.<br>\n그래서 예전에는 object fields도 랜덤하게 추출되도록 동작했다.</p>\n<p>이제 이러한 instance fields에 대한 할당 순서가 <code class=\"language-text\">__dict__</code> 에 반영되어 순서가 달라지지 않는다고 추정할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># Python 3.5</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Alpha</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n        self<span class=\"token punctuation\">.</span>b <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n        self<span class=\"token punctuation\">.</span>c <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\n\nalp <span class=\"token operator\">=</span> Alpha<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">for</span> key<span class=\"token punctuation\">,</span> value <span class=\"token keyword\">in</span> alp<span class=\"token punctuation\">.</span>__dict__<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span>\n\n<span class=\"token operator\">>></span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token string\">'c'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span></code></pre></div>\n</li>\n</ul>\n<br>\n<h3 id=\"collectionsordereddict\" style=\"position:relative;\"><a href=\"#collectionsordereddict\" aria-label=\"collectionsordereddict permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>collections.OrderedDict</h3>\n<ul>\n<li><code class=\"language-text\">collections</code> built-in module에는 dictionary의 insertion ordering을 유지하는 <code class=\"language-text\">OrderedDict</code> class가 있다.</li>\n<li>이것은 현재의 standard <code class=\"language-text\">dict</code> type과 비슷하게 동작하지만, performance의 특성은 조금 다르다.</li>\n<li>key 값을 많이 입력한 후 popitem method를 호출해야 한다면, <code class=\"language-text\">OrderedDcit</code>가 standard Python <code class=\"language-text\">dict</code> type보다 나을 수 있다.<br>\n(Item 70: Profile Before Optimizing 참고)</li>\n</ul>\n<br>\n<h3 id=\"caution\" style=\"position:relative;\"><a href=\"#caution\" aria-label=\"caution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Caution</h3>\n<ul>\n<li>Python은 dict instance가 아님에도 dictionary처럼 동작하는 object를 쉽게 만들 수 있게 한다.<br>\n이러한 object의 경우, insertion order가 유지될 것이라고 가정해서는 안 된다.</li>\n<li>Python은 type이 딱 정해지지 않아서, 대부분의 코드가 <code class=\"language-text\">duck typing</code>에 의존한다. (object의 행동이 사실상의 type이다.)</li>\n</ul>\n<br>\n<blockquote>\n<p><strong>dictionary-like classes 에 관해 조심할 수 있는 3가지 방법</strong>  </p>\n</blockquote>\n<ul>\n<li>만약에 <code class=\"language-text\">collections.abc.MutableMapping</code> 등을 이용해서 class를 생성했을 때, input 순서와는 다르게 iterates 되도록 만들어질 가능성이 있다. 이 경우에, dict 형태(dictionary-like)의 class일 뿐 dict는 아니기 때문에 조심해야 한다.</li>\n<li>\n<p><strong>첫번째: insertion ordering에 의존하지 않게 코드를 짜라.</strong></p>\n<p>-the most conservative and robust solution</p>\n<p>⇒ input이 어떻게 되었든지 순서에 상관없이 함수 안에서 원하는 결과를 얻을 수 있도록 짠다.</p>\n</li>\n<li>\n<p><strong>두번째: dict type 인지 명시적으로 체크하라.</strong></p>\n<p>-better runtime performance than the more conservative approach</p>\n<p>⇒ 함수의 맨 윗부분에서 input type을 체크해서 맞지 않으면 raise exception 한다.</p>\n</li>\n<li>\n<p><strong>세번째: type annotation이나 static analysis를 사용해서 dict value를 요구하라.</strong></p>\n<p>-best mix of static type safety and runtime performance</p>\n<p>⇒ typing module을 활용해서 parameter에 어떤 것이 입력되어야 하는지 detect 한다.</p>\n</li>\n</ul>\n<br>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em>Reference</em></h3>\n<blockquote>\n<p><a href=\"https://effectivepython.com/\"><em>Effective Python : Second Edition</em></a>  </p>\n</blockquote>","frontmatter":{"title":"Item 15: Dictionary Insertion Ordering","date":"September 13, 2020","category":"[Effective Python]","thumbnail":null}}},"pageContext":{"slug":"/effective-python/item_15/","previous":{"fields":{"slug":"/python/pycharm_refactor_debug/"},"frontmatter":{"title":"[PyCharm] Refactor, Debug","category":"python","draft":false}},"next":{"fields":{"slug":"/effective-python/item_16/"},"frontmatter":{"title":"Item 16: Prefer 'get' Over 'in' and 'KeyError' to Handle Missing Dictionary Keys","category":"[Effective Python]","draft":false}}}},"staticQueryHashes":["2353110810","3128451518"]}